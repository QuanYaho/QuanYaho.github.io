[{"title":"原生Ajax","date":"2017-10-25T10:21:06.000Z","path":"2017/10/25/原生Ajax/","text":"Ajax五步使用法: 建立XMLHTTPRequest对象 注册回调函数 当服务器回应我们了,我们想要执行什么逻辑 使用open方法设置和服务器端交互的基本信息 设置提交的网址,数据,post提交的一些额外内容 设置发送的数据，开始和服务器端交互 发送数据,更新界面 在注册的回调函数中,获取返回的数据,更新界面 XMLHttpRequest_API讲解1.创建XMLHttpRequest对象(兼容性写法) 新版本浏览器: var xml=new XMLHttpRequest(); IE5 和 IE6 var xml=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 考虑兼容性创建Ajax对象 var request ; if(XMLHttpRequest){ // 新式浏览器写法 request = new XMLHttpRequest(); }else{ //IE5,IE6写法 new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } 2.发送请求: open(method,url,async) //规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型;GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) //将请求发送到服务器。 string：仅用于 POST 请求 3.POST请求注意点: 如果想要像form表单提交数据那样使用POST请求,需要使用XMLHttpRequest对象的setRequestHeader()方法 来添加 HTTP 头。然后在 send() 方法中添加想要发送的数据： xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;); 4.onreadystatechange事件 onreadystatechange属性 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState属性 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status属性 200: “OK” 404: 未找到页面 4.服务器响应内容如果响应的是普通字符串,使用responseText,如果响应的是XML,使用responseXML responseText属性 获得字符串形式的响应数据。 responseXML属性 获得 XML 形式的响应数据。","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://www.quanyanhua.com/tags/Ajax/"}]},{"title":"网络传输协议（请求报文和响应报文）","date":"2017-10-23T05:01:00.000Z","path":"2017/10/23/http协议/","text":"请求/请求报文： 请求由客户端发出,主要有三个组成部分:请求行,请求头,请求主体 请求行: 请求方法:GET 请求URL HTTP协议版本 请求头(这里设置的主要是一些信息,包含客户端,服务器 ) User-Agent：浏览器的具体类型 Accept：浏览器支持哪些数据类型 Accept-Charset：浏览器采用的是哪种编码Accept-Encoding：浏览器支持解码的数据压缩格式 Accept-Language：浏览器的语言环境 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Connection：表示是否需要持久连接。Content-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。Referer: http://www.baidu.com/ 请求体 这里是提交给服务器的数据 需要注意的是,如果是往服务器提交数据,需要在请求头中设置Content-Type: application/x-www-form-urlencoded(在ajax中需要手动设置) 响应/响应报文 常见响应属性 Cache-Control：响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。 Cache-Control: max-age=3600 【该设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。】 ETag：一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。 它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot; Location ：我们在Asp.net中让页面Redirect到一个某个A页面中. 其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：Location: http://www.google.com.hk Set-Cookie ： 服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。 Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 HTTP响应体：如果请求的是HTML页面，那么返回的就是HTML代码。如果是JS就是JS代码。 HTTP响应头：而设置Cookie，缓存等信息就是在响应头属性设置的。 HTTP响应行：主要是设置响应状态等信息。","tags":[{"name":"http协议","slug":"http协议","permalink":"http://www.quanyanhua.com/tags/http协议/"}]},{"title":"php基础2-获取对象","date":"2017-10-22T11:03:00.000Z","path":"2017/10/22/php基础2-获取对象/","text":"$_GET对象$_GET获取通过get方法提交的数据，参数在地址栏中可见 html &lt;form action=&quot;01.php&quot; method=&quot;get&quot; &gt; &lt;label for=&quot;&quot;&gt;姓名: &lt;input type=&quot;text&quot; name= &quot;userName&quot;&gt; &lt;/label&gt; &lt;label for=&quot;&quot;&gt;邮箱: &lt;input type=&quot;text&quot; name= &quot;userEmail&quot;&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt; &lt;/form&gt; php &lt;?php echo &apos;userName:&apos;.$_GET[&apos;userName&apos;]; echo &apos;userEmail:&apos;.$_GET[&apos;userEmail&apos;]; ?&gt; $_GET[‘name属性的值’] $_POST对象$_POST获取通过post方法提交的数据参考上面的 将代码中的method改为post POST&amp;GET错误处理 当我们直接访问POST&amp;GET页面时由于并没有传递任何数据,会因为$_GET或$_POST不存在对应的key而报错. 处理方式1:使用array_key_exists(key, 数组)函数来进行判断参数1: 要检测的key字符串参数2: 检验的数组 if(array_key_exists(&apos;name&apos;, $_GET)){ //如果有数据 再去读取 }else{ // 反之 可以执行一些 其他的逻辑 } $_FILES对象 文件上传处理 &lt;form action=&quot;03.fileUpdate.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;&quot;&gt;照片: &lt;input type=&quot;file&quot; name = &quot;picture&quot; multiple=&quot;&quot;&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt; &lt;/form&gt; php &lt;?php sleep(5);// 让服务器休息一会 print_r($_FILES); ?&gt; 现象: 点击提交后,服务器没有立即出现反应,而是休息了一会sleep(5)在wamp/tmp目录下面出现了一个.tmp文件。.tmp文件一会就被自动删除了服务器返回的内容中,有文件的名字[name] =&gt; computer.png,以及上传文件保存的位置D:\\wamp\\tmp\\php3D70.tmp 【注意】&gt;在html表单中需要设置enctype=”multipart/form-data”只能post方式 PHP接收文件可以通过$_FILES来获取 如何将临时目录下面的文件保存起来 $_FILE 获取上传的文件 &lt;form action=&apos;xx.php&apos; method=&apos;post&apos; enctype=&apos;multipart/form-data&apos;&gt; &lt;input type=&apos;file&apos; name=&apos;icon&apos;&gt; &lt;input type=&apos;submit&apos;&gt; &lt;/form&gt; 【注意】 form表单中要使用post提交数据，以及要在form表单中添加enctype=multipart/form-data属性 &lt;?php // 可以打印 $_FILES的所有信息 print_r($_FILES); ?&gt; 小结： _FILES用法跟$_GET,$_POST类似,都是关系型数组 _FILE[&#39;key&#39;]:可以获取对应上传的文件,这里的key跟提交时的name相对应 _FILE[&#39;key&#39;][&#39;name&#39;] 可以获取上传的文件名 _FILE[&#39;key&#39;][&#39;tmp_name&#39;]可以获取上传的文件 move_uploaded_file()函数Array ( [picture] =&gt; Array ( [name] =&gt; computer.png [type] =&gt; image/png [tmp_name] =&gt; D:\\wamp\\tmp\\php8913.tmp [error] =&gt; 0 [size] =&gt; 5212 ) ) &lt;?php sleep(5);// 让服务器休息一会,方便我们查看上传的临时文件 // 第一个参数是 规定要移动的文件 // 第二个参数是 规定文件的新位置 move_uploaded_file($_FILES[&apos;picture&apos;][&apos;tmp_name&apos;], &apos;./upload/&apos;.$_FILES[&apos;picture&apos;][&apos;name&apos;]); ?&gt; 通过picture(根据表单标签的name属性决定)获取临时文件名以及上传文件名 move_uploaded_file(移动文件)上传的临时文件,一会就会被自动删除,我们需要将其移动到保存的位置 move_uploaded_file($_FILES[&apos;photo&apos;][&apos;tmp_name&apos;], &apos;./images/test.jpg&apos;); 参数1:移动的文件 参数2:目标路径","tags":[{"name":"php","slug":"php","permalink":"http://www.quanyanhua.com/tags/php/"}]},{"title":"php基础1","date":"2017-10-20T01:31:12.000Z","path":"2017/10/20/php基础1/","text":"1.PHP中的引号 单引号:`` 内部的内容只是作为字符串 双引号:“” 如果内部是PHP的变量,那么会将该变量的值解析 2.对象PHP中允许使用对象这种,自定义数据类型. 使用时必须先声明,实例化之后才能够使用 // 定义最基础的类 class Fox{ public $name = &apos;itcast&apos;; public $age = 10; } $fox = new $fox;// 对象属性取值 $name = $fox-&gt;name;// 对象属性赋值 $fox-&gt;name = &apos;小狐狸&apos;;// 带构造函数的对象 class fox{ // 私有属性,外部无法访问 var $name = &apos;小狐狸&apos;; // 定义方法 用来获取属性 function Name(){ return $this-&gt;name; } // 构造函数,可以传入参数 function fox($name){ $this-&gt;name = $name } } // 定义了构造函数 需要使用构造函数初始化对象 $fox = new fox(&apos;小狐狸&apos;); // 调用对象方法,获取对象名 $foxName = $fox-&gt;Name(); 3.内容输出 echo: PHP语句直接使用即可,输出字符串 print_r(): 函数输出复杂数据类型,比如数组,对象 var_dump(): 函数输出详细信息，如对象、数组 $arr =array(1,2,&apos;123&apos;); echo&apos;123&apos;; // 结果为 123 print_r($arr); // 结果为 Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 123 ) var_dump($arr); /* 结果为 array 0 =&gt; int 1 1 =&gt; int 2 2 =&gt; string &apos;123&apos; (length=3) */ 4.循环语句 for 循环 for ($x=0; $x&lt;=10; $x++) { echo &quot;数字是：$x &lt;br&gt;&quot;; } foreach 循环 $colors = array(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;); // 参数1为循环的对象,参数2会将对象的值挨个取出,直到最后 // 如果循环的是对象的话,输出的是对象属性的值 foreach ($colors as $value) { echo &quot;$value &lt;br&gt;&quot;; } 输出结果为 /* red green blue yellow */ 5.header()函数用来向客户端(浏览器)发送报头,如果出现中文无法显示,可以尝试在PHP代码顶部添加 如下代码 header(“content-type:text/html; charset=utf-8”); 6.PHP中的header浏览器访问http服务器,接收到响应时,会根据响应报文头的内容进行一些具体的操作,在php中,我们能够使用 header来设置这些内容 设置文本编——设置编码格式为:utf-8 header(&apos;content-type:text/html; charset= utf-8&apos;); 设置页面跳转—–设置跳转到百度首页 header(&apos;location:http://www.baidu.com&apos;); 设置页面间隔刷新 header(&apos;refresh:3; url=http://www.xiaomi.com&apos;);","tags":[{"name":"php","slug":"php","permalink":"http://www.quanyanhua.com/tags/php/"}]},{"title":"数组.sort()方法","date":"2017-10-15T09:09:00.000Z","path":"2017/10/15/数组的sort方法/","text":"数组去重并排序 sort实现原理 function mySort(arr,fn) { for(var i=0; i&lt;arr.length-1; i++) { //冒泡排序:外层跑的遍数 var flag = true;//用变量flag保存是否比较好了 for(var j=0; j&lt;arr.length-1-i; j++) { //冒泡排序:内层两两比较的遍数 if(fn(arr[j] , arr[j+1])&gt;0) { //通过中间变量temp，对调位置。 var temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; flag = false; } } //如果比较好了 if(flag) { break; } } return arr; } 数组去重 var arr1 = [3,6,1,2,5,2,10,2]; Array.prototype.unique = function () { var newArr = []; for(var i=0; i&lt;this.length; i++) { if(newArr.indexOf(this[i]) == -1){ newArr.push(this[i]); } } return newArr; } var newArr1 = arr1.unique(arr1); console.log(newArr1); 数组里对象的排序 var arr2 = [{ name: &quot;theOne&quot;, age: 8, skill:&quot;song&quot;, hobby:&quot;everything&quot; }, { name: &quot;theTwo&quot;, age: 30 }, { name: &quot;theThree&quot;, age: 22, height:&quot;2333...&quot; } ] var answer1 = mySort(arr1,function(a,b) { return a-b; }); var answer2 = mySort(arr2,function (a, b) { return a.age-b.age; }); var answer3 = mySort(arr2,function (a, b) { return a.length-b.length; }); console.log(answer1); console.log(answer2); console.log(answer3); 调用数组的sort方法 // console.log(arr1.sort(function (a, b) { // return a-b; // })); // console.log(arr2.sort(function (a, b) { // return a.age-b.age; // }));","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.quanyanhua.com/tags/javascript/"}]},{"title":"Function的apply和call方法","date":"2017-09-30T16:00:04.000Z","path":"2017/10/01/Function的apply和call方法/","text":"call()和apply()是Function的方法，它的第一个参数是this，第二个参数是Function的参数。这两个方法是为了动态改变this而出现的。即当一个object没有某个方法，但是其他的对象有，那就可以借助call或apply用其他对象的方法来操作。用法如下：var name = &apos;balala&apos;; function sayHello(a,b) { console.log(this.name + &apos;吃了&apos;+(a+b) +&apos;馒头&apos;); } var obj1 = { name:&apos;燕子&apos; }; var arr= []; sayHello.apply(obj1,[]); //燕子吃了NaN馒头 (this 指向obj,参数为空) arr.push(2); arr.push(8); sayHello.apply(obj1,arr); //燕子吃了10馒头 this 指向obj,参数为2,8这里obj中的name属性的值会替换掉sayHello方法中的name属性的值 1.apply1sayHello.apply(obj,arr); // 函数名.apply(对象,数组); 这句代码的意思是：obj1这个对象需要调用sayHello(参数)这个方法（函数）给自己使用，并且传入sayHello()的参数是数组arr。 #####apply(参数1,参数2)方法 参数1：将this修改成要绑定的对象。 参数2：函数需要的参数列表，它是数组Array。 2.callfunction test(a,b,c,d) { console.log(&apos;测试输出的是：&apos;+a+b+c+d); } var obj2 = { speak:&apos;嗨！朋友们&apos; } test.call(obj2,&apos;9&apos;,&apos;8&apos;,&apos;7&apos;,&apos;6&apos;);//测试输出的是：9876``` ####test.call(obj2,’9’,’8’,’7’,’6’); 函数名.call(对象,参数1,参数2,…,参数n) 这句代码的意思是：obj2这个对象需要调用test() 这个方法（函数）给自己使用，并且在test()中传入参数，注意call()是使用单个参数进行传递。 3.如何判断使用apply还是call？ 当确定函数的形参有多少个的时候使用call。 当函数的形参个数不确定时使用apply。 apply把参数打包成Array再传入，call把参数按顺序传入。 4.关于参数为null的问题 如果call和apply的第一个参数是null的话，this指向window 对于普通函数的调用，通常将this绑定为null。 Math.max.apply(null,[3,4,5]); //输出5 Math.max.call(null,7,8,9); //输出9 5.结合数组方法使用的例子var obj3 = {}; [].push.apply(obj3,[&quot;a&quot;,&quot;bb&quot;,&quot;ccc&quot;,&quot;dddd&quot;]); console.log(obj3); //输出{0: &quot;a&quot;, 1: &quot;bb&quot;, 2: &quot;ccc&quot;, 3: &quot;dddd&quot;, length: 4} 这段代码的意思：借用数组的push方法给obj3，按照下标的方式添加属性值，并且会自动维护length属性 [].pop.call(obj3); //删除并返回dddd console.log(obj3); //输出{0: &quot;a&quot;, 1: &quot;bb&quot;, 2: &quot;ccc&quot;, length: 3} 借用数组的pop方法删除obj3的最后一个属性值","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.quanyanhua.com/tags/JavaScript/"}]},{"title":"动画属性1-@keyframes","date":"2017-09-21T01:31:12.000Z","path":"2017/09/21/CSS3-动画属性1-@keyframes/","text":"@keyframes 规定动画。使 div 元素匀速向下移动： &lt;style&gt; div { width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -moz-animation:mymove 5s infinite; /* Firefox */ -webkit-animation:mymove 5s infinite; /* Safari and Chrome */ -o-animation:mymove 5s infinite; /* Opera */ } /*目前浏览器都不支持 @keyframes 规则。 Firefox 支持替代的 @-moz-keyframes 规则。 Opera 支持替代的 @-o-keyframes 规则。 Safari 和 Chrome 支持替代的 @-webkit-keyframes 规则。*/ @keyframes mymove { from {top:0px;} to {top:200px;} } @-moz-keyframes mymove /* Firefox */ { from {top:0px;} to {top:200px;} } @-webkit-keyframes mymove /* Safari and Chrome */ { from {top:0px;} to {top:200px;} } @-o-keyframes mymove /* Opera */ { from {top:0px;} to {top:200px;} } &lt;/style&gt; &lt;div&gt;&lt;/div&gt; 语法@keyframes animationname {keyframes-selector {css-styles;}} animationname 必需。定义动画的名称。 keyframes-selector 必需。动画时长的百分比。 合法的值： 0-100% from（与 0% 相同）to（与 100% 相同） css-styles 必需。一个或多个合法的 CSS 样式属性。 在一个动画中添加多个 keyframe 选择器： &lt;style&gt; div { width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -moz-animation:mymove 5s infinite; /* Firefox */ -webkit-animation:mymove 5s infinite; /* Safari and Chrome */ -o-animation:mymove 5s infinite; /* Opera */ } @keyframes mymove { 0% {top:0px;} 25% {top:200px;} 75% {top:50px} 100% {top:100px;} } @-moz-keyframes mymove /* Firefox */ { 0% {top:0px;} 25% {top:200px;} 75% {top:50px} 100% {top:100px;} } @-webkit-keyframes mymove /* Safari and Chrome */ { 0% {top:0px;} 25% {top:200px;} 75% {top:50px} 100% {top:100px;} } @-o-keyframes mymove /* Opera */ { 0% {top:0px;} 25% {top:200px;} 75% {top:50px} 100% {top:100px;} } &lt;/style&gt; &lt;div&gt;&lt;/div&gt;","tags":[{"name":"css3","slug":"css3","permalink":"http://www.quanyanhua.com/tags/css3/"}]},{"title":"动画属性3-animation","date":"2017-09-21T01:31:12.000Z","path":"2017/09/21/CSS3-动画属性3-animation/","text":"animation-name 规定 @keyframes 动画的名称。为 @keyframes 动画规定一个名称： div { animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */ } animation-duration 规定动画完成一个周期所花费的秒或毫秒。div { animation-duration:2s; -webkit-animation-duration:2s; /* Safari 和 Chrome */ } animation-timing-function 规定动画的速度曲线。从开头到结尾以相同的速度来播放动画： div { animation-timing-function:2s; -webkit-animation-timing-function:2s; /* Safari 和 Chrome */ } animation-delay 规定动画何时开始。等待两秒，然后开始动画： div { animation-delay:2s; -webkit-animation-delay:2s; /* Safari 和 Chrome */ } animation-iteration-count 规定动画被播放的次数。播放动画三次： div { animation-iteration-count:3; -webkit-animation-iteration-count:3; /* Safari 和 Chrome */ } animation-direction 规定动画是否在下一周期逆向地播放。暂停动画： div { animation-direction:alternate; -webkit-animation-direction:alternate; /* Safari 和 Chrome */ } animation-play-state 规定动画是否正在运行或暂停。暂停动画： div { animation-play-state:paused; -webkit-animation-play-state:paused; /* Safari 和 Chrome */ } animation-fill-mode 规定对象动画时间之外的状态。为 h1 元素规定填充模式： h1 { animation-fill-mode: forwards; } animation-fill-mode 属性规定动画在播放之前或之后，其动画效果是否可见。 注释：其属性值是由逗号分隔的一个或多个填充模式关键词。 语法 animation-fill-mode : none | forwards | backwards | both; 值: none 不改变默认行为。 forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。 backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both 向前和向后填充模式都被应用。","tags":[{"name":"css3","slug":"css3","permalink":"http://www.quanyanhua.com/tags/css3/"}]},{"title":"动画属性2-animation","date":"2017-09-21T01:31:12.000Z","path":"2017/09/21/CSS3-动画属性2-animation/","text":"animation 所有动画属性的简写属性，除了 animation-play-state 属性。div { animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */ } 定义和用法 animation 属性是一个简写属性，用于设置六个动画属性： 语法 animation: name duration timing-function delay iteration-count direction; 值: animation-name 规定需要绑定到选择器的 keyframe 名称。。 animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画。 默认值： none 0 ease 0 1 normal 注释：请始终规定 animation-duration 属性，否则时长为 0，就不会播放动画了。 使用简写属性，将动画与 div 元素绑定： &lt;style&gt; div { width:100px; height:100px; background:red; position:relative; animation:mymove 5s infinite; -webkit-animation:mymove 5s infinite; /*Safari and Chrome*/ } @keyframes mymove { from {left:0px;} to {left:200px;} } @-webkit-keyframes mymove /*Safari and Chrome*/ { from {left:0px;} to {left:200px;} } &lt;/style&gt; &lt;div&gt;&lt;/div&gt; JavaScript 语法： object.style.animation=”mymove 5s infinite”","tags":[{"name":"css3","slug":"css3","permalink":"http://www.quanyanhua.com/tags/css3/"}]},{"title":"2D/3D 转换属性（Transform）","date":"2017-09-20T08:19:03.000Z","path":"2017/09/20/CSS3-2D3D 转换属性Transform/","text":"transform属性 向元素应用 2D 或 3D 转换。 transform属性允许我们对元素进行旋转、缩放、移动或倾斜。 div { transform:rotate(7deg); -ms-transform:rotate(7deg); /* IE 9 */ -moz-transform:rotate(7deg); /* Firefox */ -webkit-transform:rotate(7deg); /* Safari 和 Chrome */ -o-transform:rotate(7deg); /* Opera */ } 取值： none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 translate(x,y) 定义 2D 转换。 #MyDIV { transform:translate(10px); } translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。（元素在X轴平移） translateY(y) 定义转换，只是用 Y 轴的值。（元素在y轴平移） #MyDIV { transform:translateY(10px); } translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 - &lt;b&gt;`scale(x,y)` 定义 2D 缩放转换。&lt;/b&gt; #MyDIV { transform:scale(1.1,1.1); } &lt;b&gt;`scale3d(x,y,z)` 定义 3D 缩放转换。&lt;/b&gt; `scaleX(x)` 通过设置 X 轴的值来定义缩放转换。 #MyDIV { transform:scaleX(0.5); } `scaleY(y)` 通过设置 Y 轴的值来定义缩放转换。&lt;br&gt; `scaleZ(z)` 通过设置 Z 轴的值来定义 3D 缩放转换。&lt;br&gt; - &lt;b&gt;`rotate(angle)` 定义 2D 旋转，在参数中规定角度。&lt;/b&gt; #MyDIV { transform:rotate(45deg); } &lt;b&gt;`rotate3d(x,y,z,angle)` 定义 3D 旋转。&lt;/b&gt;&lt;br&gt; rotateX(angle) 定义沿着 X 轴的 3D 旋转。&lt;br&gt; rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 &lt;br&gt; rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 &lt;b&gt;`skew(x-angle,y-angle)`定义沿着 X 和 Y 轴的 2D 倾斜转换。&lt;/b&gt; &lt;br&gt; skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 &lt;br&gt; skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。&lt;br&gt; - &lt;b&gt;`perspective(n)` 为 3D 转换元素定义透视视图。&lt;/b&gt; transform-origin 允许你改变被转换元素的位置。例子：设置旋转元素的基点位置： div { transform: rotate(45deg); transform-origin:20% 40%; } 注释：该属性必须与 transform 属性一同使用。 语法 transform-origin: x-axis y-axis z-axis; 默认值： 50% 50% 0 - `x-axis`：定义视图被置于 X 轴的何处 可能的值： - left - center - right - length - % - `y-axis`：定义视图被置于 Y 轴的何处 - top - center - bottom - length - % - `z-axis`：定义视图被置于 Z 轴的何处 - length transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。例子：使被转换的子元素保留其 3D 转换： div { transform: rotateY(60deg); transform-style: preserve-3d; } 注释：该属性必须与 transform 属性一同使用。 语法transform-style: flat|preserve-3d; flat 子元素将不保留其 3D 位置。 preserve-3d 子元素将保留其 3D 位置。 perspective 规定 3D 元素的透视效果。例子：设置元素被查看位置的视图： div { perspective: 500; // 元素距离视图的距离，以像素计 -webkit-perspective: 500; /* Safari 和 Chrome */ } 目前浏览器都不支持 perspective 属性。Chrome 和 Safari 支持替代的 -webkit-perspective 属性。 定义和用法 perspective 属性定义 3D 元素距视图的距离，以像素计。 该属性允许您改变 3D 元素查看 3D 元素的视图。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 注释：perspective 属性只影响 3D 转换元素。 perspective-origin 规定 3D 元素的底部位置。backface-visibility 定义元素在不面对屏幕时是否可见。JavaScript 语法：object.style.transform=&quot;rotate(7deg)&quot; object.style.transformStyle=&quot;preserve-3d&quot;","tags":[{"name":"css3","slug":"css3","permalink":"http://www.quanyanhua.com/tags/css3/"}]},{"title":"过渡属性：transition","date":"2017-09-20T06:11:56.000Z","path":"2017/09/20/CSS3-过渡属性transition /","text":"transform(缩放、旋转、平移)，显示的是最终效果，没有动画过程transition是对元素本身的属性(比如：width、height)设置动画效果 过渡：transition语法:transition: property duration timing-function delay; 宽高等属性（none,all,width/height）、 时长(必须)、 速度曲线效果（默认ease：慢-快-慢）、 延迟几秒开始 div { width:100px; transition: width 2s; } 详细知识点 语法 transition: property duration timing-function delay; transition 属性是一个简写属性，用于设置四个过渡属性请始终设置 transition-duration 属性，否则时长为 0，就不会产生过渡效果 例子 div { width:100px; transition: width 2s; -moz-transition: width 2s; /* Firefox 4 */ -webkit-transition: width 2s; /* Safari 和 Chrome */ -o-transition: width 2s; /* Opera */ } transition的四个过渡属性 transition-property 属性：规定设置过渡效果的 CSS 属性的名称。如：width。 当指定的 CSS 属性改变时，过渡效果将开始 取值：none： 没有属性有过渡效果。all： 所有属性都有过渡效果。property： 定义应用过渡效果的CSS 属性名称列表，列表以逗号分隔。 transition-duration 属性：（必须）规定完成过渡效果需要的时间（以秒或毫秒计）。如：5s transition-timing-function属性：规定速度效果的速度曲线。 transition-timing-function: linear; 默认值：ease 取值：linear：匀速ease：慢-快-慢ease-in：以慢速开始ease-out：以慢速结束ease-in-out：以慢速开始与结束cubic-bezier(n,n,n,n)： 在cubic-bezier 函数中定义自己的值。 0 - 1 的数值。如：transition-timing-function: cubic-bezier(0.25,0.1,0.25,1); transition-delay属性：定义过渡效果何时开始。 JavaScript 语法：object.style.transition=&quot;width 2s&quot;； object.style.transitionProperty=&quot;width,height&quot;； object.style.transitionTimingFunction=&quot;linear&quot;；","tags":[{"name":"css3","slug":"css3","permalink":"http://www.quanyanhua.com/tags/css3/"}]},{"title":"表单对齐","date":"2017-08-05T14:31:00.000Z","path":"2017/08/05/表单对齐/","text":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span{ width: 100px; text-align: justify; float: left; } span:after{ content:&apos;.&apos;; width: 100%; display: inline-block; overflow: hidden; height: 0; } input{ width: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;demo&quot;&gt; &lt;span&gt;昵称&lt;/span&gt;：&lt;input type=&quot;text&quot; style = &apos;width: 100px&apos;&gt;&lt;br&gt;&lt;br&gt; &lt;span&gt;电子邮箱&lt;/span&gt;：&lt;input type=&quot;email&quot; style = &apos;width: 100px;&apos;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"css","slug":"css","permalink":"http://www.quanyanhua.com/tags/css/"}]},{"title":"hexo常用命令","date":"2017-08-01T00:55:12.000Z","path":"2017/08/01/hexo常用命令/","text":"创建文章 hexo new “New article Name” 会在f:\\blog\\source目录下生成一个md文件 可以简写成 hexo n “New article Name” 部署到Github 部署到Github前需要配置_config.yml文件 # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: 改成： # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: github仓库的ssh branch: master 如果是为一个项目制作网站，那么需要把branch设置为gh-pages。 同步到hexo和GitHub失败 错误提示： ERROR Deployer not found: github 解决办法： npm install hexo-deployer-git --save 改了之后执行，然后再部署 问题根源：hexo 更新到3.0之后，deploy的type 的github需要改成git 部署步骤 hexo clean hexo generate hexo deploy hexo g #生成 hexo s #启动本地服务，进行文章预览调试 常用命令 hexo 命令 hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo deploy -g #生成加部署hexo server -g #生成加预览 命令的简写 hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 部署文件需要三步 hexo c hexo g hexo d 复合命令 hexo deploy -g #生成加部署 hexo server -g #生成加预览","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.quanyanhua.com/tags/hexo/"}]},{"title":"css的margin属性","date":"2017-07-03T02:01:03.000Z","path":"2017/07/03/css的margin属性/","text":"1.标准流中的margin水平：左右两个盒子的外边距是可以叠加的，不会丢失垂直： 上下两个盒子，谁的外边距大，听谁的（外边距的合并） 什么是外边距重叠？重叠的结果是什么？外边距重叠就是margin-collapse。在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠结果遵循下列计算规则：两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果是两者的相加的和。 2.box-sizing取值box-sizing:content-box // 元素的宽高 = 边框 + 内边距 + 内容宽高 （默认取值）&lt;br&gt; box-sizing:border-box // 元素的宽高 = width/height的宽高 3.两个嵌套关系的盒子 (1) 如果里面的盒子设置了margin-top，那么父盒子也会被顶下来。 ——解决：给父盒子添加border属性 建议：实现嵌套关系的盒子之间的距离时应该先考虑padding，其次考虑margin。margin本质上是用于控制兄弟之间的间隙的。Padding是用来控制父子关系的。 (2) margin： 0 auto; 只对水平方向有效，对垂直方向无效。在嵌套关系的盒子中，子盒子相对于父盒子水平居中。 4.BFCBFC(block formatting context）：简单来说，BFC 就是一种属性，这种属性会影响着元素的定位以及与其兄弟元素之间的相互作用。 BFC（块级格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题。BFC是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用 5.两种CSS的盒子模型？标准 W3C 盒子模型：内容(content)、填充(padding)、边界(margin)、 边框(border)IE 盒子模型：IE 的content部分包含了 border 和 pading","tags":[{"name":"css","slug":"css","permalink":"http://www.quanyanhua.com/tags/css/"}]}]